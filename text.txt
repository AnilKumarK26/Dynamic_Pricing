from flask import Flask, render_template, jsonify, request, session
import numpy as np
import pandas as pd
import json
from datetime import datetime
import os

# Import your RL components (uncomment when ready)
# from environment.airline_env import AirlineRevenueEnv
# from agents.model import DQNAgent
# from utils.preprocessing import FlightDataProcessor

app = Flask(__name__)
app.secret_key = 'airline_rl_secret_key_2024'

# Global variables to store simulation state
class SimulationState:
    def __init__(self):
        self.reset()
    
    def reset(self):
        self.current_step = 0
        self.current_price = 6000
        self.seats_sold = 0
        self.total_seats = 180
        self.total_revenue = 0
        self.days_to_departure = 90
        self.disruption = 'none'
        self.history = []
        self.competitor_prices = {
            'SpiceJet': 5950,
            'AirAsia': 5960,
            'Vistara': 5940,
            'IndiGo': 5970
        }
        
sim_state = SimulationState()

# Load flight data
def load_data():
    """Load REAL flight dataset"""
    data_path = 'data/flight_data.csv'
    if os.path.exists(data_path):
        df = pd.read_csv(data_path)
        print(f"‚úì Loaded {len(df)} real flight records")
        return df
    else:
        print("‚ö†Ô∏è  No flight_data.csv found!")
        print("   Please add your CSV file to data/ folder")
        print("   Required columns: airline, route, price, from, to")
        return None

flight_data = load_data()

@app.route('/')
def index():
    """Main dashboard page"""
    return render_template('index.html')

@app.route('/api/state')
def get_state():
    """Get current simulation state"""
    load_factor = (sim_state.seats_sold / sim_state.total_seats) * 100
    
    return jsonify({
        'current_price': round(sim_state.current_price, 2),
        'seats_sold': sim_state.seats_sold,
        'total_seats': sim_state.total_seats,
        'load_factor': round(load_factor, 1),
        'total_revenue': round(sim_state.total_revenue, 2),
        'days_to_departure': sim_state.days_to_departure,
        'disruption': sim_state.disruption,
        'competitor_prices': sim_state.competitor_prices,
        'step': sim_state.current_step
    })

@app.route('/api/action', methods=['POST'])
def take_action():
    """Execute pricing action"""
    data = request.json
    action = data.get('action', 'hold')
    
    # Price adjustments
    price_changes = {
        'decrease_20': -0.20,
        'decrease_10': -0.10,
        'hold': 0.0,
        'increase_10': 0.10,
        'increase_20': 0.20
    }
    
    adjustment = price_changes.get(action, 0.0)
    old_price = sim_state.current_price
    sim_state.current_price *= (1 + adjustment)
    sim_state.current_price = max(3000, min(15000, sim_state.current_price))
    
    # Simulate bookings based on price competitiveness
    avg_competitor = np.mean(list(sim_state.competitor_prices.values()))
    price_ratio = sim_state.current_price / avg_competitor
    
    # Base demand
    demand_factor = 1 / (1 + np.exp(5 * (price_ratio - 1)))
    
    # Time factor (more bookings as departure approaches)
    time_factor = 1 - (sim_state.days_to_departure / 90)
    
    # Disruption effects
    disruption_factor = 1.0
    if sim_state.disruption == 'weather':
        disruption_factor = 0.6
    elif sim_state.disruption == 'pilot_strike':
        disruption_factor = 0.3
    elif sim_state.disruption == 'competitor_cancel':
        disruption_factor = 1.5
    
    # Calculate bookings
    expected_bookings = 15 * demand_factor * time_factor * disruption_factor
    bookings = max(0, int(np.random.poisson(expected_bookings)))
    bookings = min(bookings, sim_state.total_seats - sim_state.seats_sold)
    
    # Update state
    sim_state.seats_sold += bookings
    revenue_this_step = bookings * sim_state.current_price
    sim_state.total_revenue += revenue_this_step
    sim_state.days_to_departure -= 1
    sim_state.current_step += 1
    
    # Update competitor prices (random walk)
    for airline in sim_state.competitor_prices:
        change = np.random.normal(0, 50)
        sim_state.competitor_prices[airline] += change
        sim_state.competitor_prices[airline] = max(3000, min(15000, 
                                                    sim_state.competitor_prices[airline]))
    
    # Record history
    sim_state.history.append({
        'step': sim_state.current_step,
        'price': round(sim_state.current_price, 2),
        'bookings': bookings,
        'revenue': round(revenue_this_step, 2),
        'seats_sold': sim_state.seats_sold,
        'disruption': sim_state.disruption
    })
    
    # Calculate reward
    reward = revenue_this_step / 1000
    if sim_state.days_to_departure < 7 and sim_state.seats_sold < sim_state.total_seats * 0.5:
        reward -= 5  # Penalty for low bookings near departure
    
    done = (sim_state.days_to_departure <= 0) or (sim_state.seats_sold >= sim_state.total_seats)
    
    return jsonify({
        'success': True,
        'bookings': bookings,
        'revenue': round(revenue_this_step, 2),
        'reward': round(reward, 2),
        'new_price': round(sim_state.current_price, 2),
        'old_price': round(old_price, 2),
        'done': done,
        'message': f'Sold {bookings} seats at ‚Çπ{sim_state.current_price:.0f}'
    })

@app.route('/api/disruption', methods=['POST'])
def trigger_disruption():
    """Trigger a disruption event"""
    data = request.json
    disruption_type = data.get('type', 'none')
    
    sim_state.disruption = disruption_type
    
    messages = {
        'weather': '‚õàÔ∏è Weather delay triggered! Demand will decrease.',
        'pilot_strike': '‚úä Pilot strike! Major impact on demand.',
        'competitor_cancel': '‚úàÔ∏è Competitor cancelled flights! Opportunity to capture demand.',
        'none': '‚úÖ Normal operations resumed.'
    }
    
    return jsonify({
        'success': True,
        'disruption': disruption_type,
        'message': messages.get(disruption_type, 'Unknown disruption')
    })

@app.route('/api/reset', methods=['POST'])
def reset_simulation():
    """Reset simulation to initial state"""
    sim_state.reset()
    return jsonify({
        'success': True,
        'message': 'Simulation reset to initial state'
    })

@app.route('/api/history')
def get_history():
    """Get simulation history"""
    return jsonify({
        'history': sim_state.history[-100:]  # Last 100 steps
    })

@app.route('/api/ai_recommendation')
def get_ai_recommendation():
    """Get AI agent's recommended action"""
    # This would use your trained RL agent
    # For now, use simple heuristic
    
    avg_competitor = np.mean(list(sim_state.competitor_prices.values()))
    price_diff = sim_state.current_price - avg_competitor
    load_factor = sim_state.seats_sold / sim_state.total_seats
    
    # Simple decision logic
    if price_diff > 200 and load_factor < 0.5:
        recommendation = 'decrease_10'
        reason = 'Price too high vs competitors, low bookings'
    elif price_diff < -200 and load_factor > 0.7:
        recommendation = 'increase_10'
        reason = 'Price too low, strong demand'
    elif sim_state.days_to_departure < 7 and load_factor < 0.6:
        recommendation = 'decrease_20'
        reason = 'Near departure, need to fill seats'
    elif sim_state.disruption == 'competitor_cancel':
        recommendation = 'increase_20'
        reason = 'Competitor cancelled, high demand'
    else:
        recommendation = 'hold'
        reason = 'Current pricing is optimal'
    
    return jsonify({
        'action': recommendation,
        'reason': reason,
        'confidence': 0.85
    })

@app.route('/api/analytics')
def get_analytics():
    """Get analytics data"""
    if not sim_state.history:
        return jsonify({'error': 'No data available'})
    
    df = pd.DataFrame(sim_state.history)
    
    analytics = {
        'total_revenue': round(sim_state.total_revenue, 2),
        'avg_price': round(df['price'].mean(), 2),
        'total_bookings': int(df['bookings'].sum()),
        'load_factor': round((sim_state.seats_sold / sim_state.total_seats) * 100, 1),
        'revenue_per_seat': round(sim_state.total_revenue / max(sim_state.seats_sold, 1), 2),
        'steps_completed': sim_state.current_step
    }
    
    return jsonify(analytics)

@app.route('/api/dataset_info')
def get_dataset_info():
    """Get information about the REAL dataset"""
    if flight_data is None:
        return jsonify({'error': 'No flight data loaded'})
    
    # Get available routes
    routes = {}
    if 'route' in flight_data.columns:
        route_counts = flight_data['route'].value_counts()
        for route, count in route_counts.items():
            route_data = flight_data[flight_data['route'] == route]
            routes[route] = {
                'count': int(count),
                'avg_price': float(route_data['price'].mean()),
                'airlines': int(route_data['airline'].nunique())
            }
    
    info = {
        'total_flights': len(flight_data),
        'airlines': flight_data['airline'].nunique() if 'airline' in flight_data.columns else 0,
        'routes': routes,
        'avg_price': round(flight_data['price'].mean(), 2) if 'price' in flight_data.columns else 0,
        'price_range': {
            'min': round(flight_data['price'].min(), 2) if 'price' in flight_data.columns else 0,
            'max': round(flight_data['price'].max(), 2) if 'price' in flight_data.columns else 0
        }
    }
    return jsonify(info)

if __name__ == '__main__':
    # Create templates folder if it doesn't exist
    os.makedirs('templates', exist_ok=True)
    os.makedirs('static/css', exist_ok=True)
    os.makedirs('static/js', exist_ok=True)
    
    print("\n" + "="*70)
    print("  üöÄ AIRLINE RL DASHBOARD STARTING")
    print("="*70)
    print("\n  üìä Dashboard: http://localhost:5000")
    print("  üìÅ API Endpoints:")
    print("     - GET  /api/state")
    print("     - POST /api/action")
    print("     - POST /api/disruption")
    print("     - POST /api/reset")
    print("     - GET  /api/ai_recommendation")
    print("\n  Press Ctrl+C to stop\n")
    
    app.run(debug=True, host='0.0.0.0', port=5000)



    ????????????????????????????????????????????????????????????????
    ?????????????????????????????????????????????????????????????????
    preprocessing.py 
    ??????????????????????????????????????????????????????????????????
    \>??????????????????????????????????????????????????????????????????
    """
Real Flight Data Preprocessing
File: utils/preprocessing.py
Uses ACTUAL flight data to calibrate the environment
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, StandardScaler
import pickle
import os


class FlightDataProcessor:
    def __init__(self):
        self.label_encoders = {}
        self.scaler = StandardScaler()
        self.route_stats = {}
        
    def load_data(self, filepath='data/flight_data.csv'):
        """Load REAL flight dataset"""
        if not os.path.exists(filepath):
            raise FileNotFoundError(
                f"\n‚ùå Flight data not found at: {filepath}\n"
                f"Please add your flight_data.csv to the data/ folder!\n"
                f"Required columns: airline, from, to, route, price, duration_in_min, stops, class_category"
            )
        
        df = pd.read_csv(filepath)
        print(f"‚úì Loaded {len(df)} flight records from real data")
        
        # Validate required columns
        required_cols = ['airline', 'price', 'route']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            raise ValueError(f"Missing required columns: {missing_cols}")
        
        return df
    
    def get_available_routes(self, df):
        """Get all unique routes in the dataset"""
        if 'route' not in df.columns:
            # Try to create route from 'from' and 'to' columns
            if 'from' in df.columns and 'to' in df.columns:
                df['route'] = df['from'] + '-' + df['to']
            else:
                raise ValueError("No route information found in data")
        
        routes = df['route'].value_counts()
        print("\nüìç Available Routes:")
        for route, count in routes.items():
            print(f"   {route}: {count} flights")
        
        return routes.index.tolist()
    
    def analyze_route(self, df, route):
        """
        Analyze a specific route to get REAL statistics for calibration
        This is CRITICAL for environment realism!
        """
        route_df = df[df['route'] == route].copy()
        
        if len(route_df) == 0:
            raise ValueError(f"No data found for route: {route}")
        
        print(f"\nüîç Analyzing Route: {route}")
        print(f"   Total flights: {len(route_df)}")
        
        # Price statistics (REAL data)
        price_stats = {
            'mean': route_df['price'].mean(),
            'std': route_df['price'].std(),
            'min': route_df['price'].min(),
            'max': route_df['price'].max(),
            'q25': route_df['price'].quantile(0.25),
            'q75': route_df['price'].quantile(0.75),
        }
        
        print(f"\nüí∞ Price Statistics (Real Data):")
        print(f"   Mean: ‚Çπ{price_stats['mean']:.2f}")
        print(f"   Std Dev: ‚Çπ{price_stats['std']:.2f}")
        print(f"   Range: ‚Çπ{price_stats['min']:.0f} - ‚Çπ{price_stats['max']:.0f}")
        print(f"   25th percentile: ‚Çπ{price_stats['q25']:.0f}")
        print(f"   75th percentile: ‚Çπ{price_stats['q75']:.0f}")
        
        # Airlines on this route (REAL competitors)
        airlines = route_df['airline'].value_counts()
        print(f"\n‚úàÔ∏è Airlines on this route:")
        for airline, count in airlines.items():
            avg_price = route_df[route_df['airline'] == airline]['price'].mean()
            print(f"   {airline}: {count} flights (avg: ‚Çπ{avg_price:.0f})")
        
        # Get competitor prices (REAL data)
        competitor_prices = {}
        for airline in airlines.index:
            competitor_prices[airline] = route_df[route_df['airline'] == airline]['price'].mean()
        
        # Duration statistics (if available)
        duration_stats = None
        if 'duration_in_min' in route_df.columns:
            duration_stats = {
                'mean': route_df['duration_in_min'].mean(),
                'std': route_df['duration_in_min'].std(),
            }
            print(f"\n‚è±Ô∏è Duration: {duration_stats['mean']:.0f} ¬± {duration_stats['std']:.0f} minutes")
        
        # Stops analysis (if available)
        if 'stops' in route_df.columns:
            stops_dist = route_df['stops'].value_counts(normalize=True)
            print(f"\nüõ¨ Stops Distribution:")
            for stops, pct in stops_dist.items():
                print(f"   {stops} stops: {pct*100:.1f}%")
        
        # Class distribution (if available)
        if 'class_category' in route_df.columns:
            class_dist = route_df['class_category'].value_counts(normalize=True)
            print(f"\nüí∫ Class Distribution:")
            for cls, pct in class_dist.items():
                print(f"   {cls}: {pct*100:.1f}%")
        
        # Store statistics for this route
        route_stats = {
            'route': route,
            'n_flights': len(route_df),
            'price_stats': price_stats,
            'competitor_prices': competitor_prices,
            'airlines': airlines.to_dict(),
            'duration_stats': duration_stats,
        }
        
        self.route_stats[route] = route_stats
        
        return route_stats
    
    def get_calibrated_env_params(self, route_stats):
        """
        Convert route statistics to environment parameters
        This ensures the RL environment uses REAL data patterns!
        """
        params = {
            # Base pricing from REAL data
            'base_price': route_stats['price_stats']['mean'],
            'price_std': route_stats['price_stats']['std'],
            'price_min': route_stats['price_stats']['q25'],  # Conservative min
            'price_max': route_stats['price_stats']['q75'] * 1.5,  # Allow surge pricing
            
            # Competitor prices from REAL data
            'competitor_prices': route_stats['competitor_prices'],
            
            # Realistic booking parameters
            'total_seats': 180,  # Standard single-aisle aircraft
            'max_days_before_departure': 90,
            
            # Demand parameters (calibrated to realistic booking patterns)
            'base_demand_rate': 0.15,  # 15% of capacity per day on average
            'price_elasticity': 2.0,  # How sensitive demand is to price
            
            # Time-based booking curve (more bookings closer to departure)
            'early_booking_factor': 0.3,  # Lower demand 90 days out
            'late_booking_factor': 1.5,   # Higher demand close to departure
        }
        
        print(f"\n‚öôÔ∏è Calibrated Environment Parameters:")
        print(f"   Base Price: ‚Çπ{params['base_price']:.0f}")
        print(f"   Price Range: ‚Çπ{params['price_min']:.0f} - ‚Çπ{params['price_max']:.0f}")
        print(f"   Competitors: {len(params['competitor_prices'])}")
        print(f"   Total Seats: {params['total_seats']}")
        
        return params
    
    def preprocess(self, df):
        """Preprocess flight data for RL"""
        df_processed = df.copy()
        
        # Encode categorical variables
        categorical_cols = ['airline', 'from', 'to', 'route']
        
        for col in categorical_cols:
            if col in df_processed.columns:
                le = LabelEncoder()
                df_processed[col + '_encoded'] = le.fit_transform(df_processed[col].astype(str))
                self.label_encoders[col] = le
        
        # Feature engineering
        if 'duration_in_min' in df_processed.columns:
            df_processed['price_per_minute'] = df_processed['price'] / df_processed['duration_in_min']
        
        if 'dep_hour' in df_processed.columns:
            df_processed['is_morning_flight'] = (df_processed['dep_hour'] >= 6) & (df_processed['dep_hour'] < 12)
            df_processed['is_evening_flight'] = (df_processed['dep_hour'] >= 18) & (df_processed['dep_hour'] < 24)
        
        return df_processed
    
    def save_route_stats(self, filepath='data/route_stats.pkl'):
        """Save analyzed route statistics"""
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'wb') as f:
            pickle.dump(self.route_stats, f)
        print(f"\n‚úì Route statistics saved to {filepath}")
    
    def load_route_stats(self, filepath='data/route_stats.pkl'):
        """Load analyzed route statistics"""
        if os.path.exists(filepath):
            with open(filepath, 'rb') as f:
                self.route_stats = pickle.load(f)
            print(f"‚úì Route statistics loaded from {filepath}")
        else:
            print(f"‚ö†Ô∏è  No saved route statistics found at {filepath}")


# Main execution for data analysis
if __name__ == "__main__":
    print("="*70)
    print("  REAL FLIGHT DATA ANALYSIS")
    print("="*70)
    
    try:
        processor = FlightDataProcessor()
        
        # Load REAL data
        df = processor.load_data('data/flight_data.csv')
        
        # Get available routes
        routes = processor.get_available_routes(df)
        
        # Analyze first route (or you can specify)
        if routes:
            selected_route = routes[0]  # Change this to analyze different routes
            print(f"\nüéØ Selected Route: {selected_route}")
            
            # Analyze route with REAL data
            route_stats = processor.analyze_route(df, selected_route)
            
            # Get calibrated parameters
            env_params = processor.get_calibrated_env_params(route_stats)
            
            # Save statistics
            processor.save_route_stats()
            
            print("\n" + "="*70)
            print("  ‚úì ANALYSIS COMPLETE")
            print("="*70)
            print("\nUse these parameters in your environment for realistic simulation!")
            
        else:
            print("\n‚ùå No routes found in data!")
            
    except FileNotFoundError as e:
        print(f"\n‚ùå Error: {e}")
        print("\nüí° Solution:")
        print("   1. Add your flight_data.csv to the data/ folder")
        print("   2. Ensure it has columns: airline, route, price")
        print("   3. Run this script again")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()




????????????????????????????????????????????????????????????????????
?????????????????????????????????????????????????????????????????????
analyze_data.py
???????????????????????????????????????????????????????????????????????
???????????????????????????????????????????????????????????????????????

"""
Analyze Real Flight Data and Calibrate Environment
Run this FIRST to understand your data and set up the environment
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from utils.preprocessing import FlightDataProcessor
import os

def main():
    print("="*80)
    print("  REAL FLIGHT DATA ANALYSIS & CALIBRATION")
    print("="*80)
    
    # Check if data exists
    data_path = 'data/flight_data.csv'
    if not os.path.exists(data_path):
        print(f"\n‚ùå ERROR: No flight data found at {data_path}")
        print("\nüìã Required Steps:")
        print("   1. Add your CSV file to: data/flight_data.csv")
        print("   2. Ensure it has these columns:")
        print("      - airline (e.g., 'SpiceJet', 'IndiGo')")
        print("      - from (e.g., 'Delhi')")
        print("      - to (e.g., 'Mumbai')")
        print("      - route (e.g., 'Delhi-Mumbai') OR we'll create it")
        print("      - price (e.g., 5953)")
        print("   3. Optional columns: duration_in_min, stops, class_category")
        print("\nüí° Your data format example:")
        print("   airline,from,to,price,duration_in_min")
        print("   SpiceJet,Delhi,Mumbai,5953,130")
        print("   AirAsia,Delhi,Mumbai,5956,130")
        return
    
    # Load processor
    processor = FlightDataProcessor()
    
    try:
        # Load data
        print("\nüìÇ Loading flight data...")
        df = processor.load_data(data_path)
        
        # Show data info
        print(f"\nüìä Dataset Overview:")
        print(f"   Total Records: {len(df)}")
        print(f"   Columns: {', '.join(df.columns)}")
        
        # Get available routes
        print("\n" + "-"*80)
        routes = processor.get_available_routes(df)
        
        if not routes:
            print("\n‚ùå No routes found in data!")
            return
        
        # Let user select route or use first one
        print(f"\nüéØ Found {len(routes)} routes")
        print("\nSelect a route to analyze:")
        for i, route in enumerate(routes[:10], 1):  # Show first 10
            count = len(df[df['route'] == route])
            print(f"   {i}. {route} ({count} flights)")
        
        if len(routes) > 10:
            print(f"   ... and {len(routes)-10} more routes")
        
        # For now, analyze the route with most data
        selected_route = df['route'].value_counts().index[0]
        print(f"\n‚ú® Analyzing route with most data: {selected_route}")
        
        print("\n" + "="*80)
        
        # DEEP ANALYSIS of selected route
        route_stats = processor.analyze_route(df, selected_route)
        
        # Get calibrated parameters
        print("\n" + "-"*80)
        env_params = processor.get_calibrated_env_params(route_stats)
        
        # Save statistics
        processor.save_route_stats()
        
        # Create visualizations
        print("\nüìä Creating visualizations...")
        create_route_visualizations(df, selected_route)
        
        # Summary and recommendations
        print("\n" + "="*80)
        print("  ‚úÖ ANALYSIS COMPLETE!")
        print("="*80)
        
        print("\nüìà Key Insights:")
        print(f"   Route: {selected_route}")
        print(f"   Base Price: ‚Çπ{route_stats['price_stats']['mean']:.0f}")
        print(f"   Price Std Dev: ‚Çπ{route_stats['price_stats']['std']:.0f}")
        print(f"   Competitors: {len(route_stats['competitor_prices'])}")
        print(f"   Total Flights in Data: {route_stats['n_flights']}")
        
        print("\nüéØ Next Steps:")
        print("   1. ‚úì Route statistics saved to data/route_stats.pkl")
        print("   2. ‚úì Visualizations saved to results/")
        print("   3. Run: python app.py (to start web dashboard)")
        print("   4. Run: python main.py --route '{}'".format(selected_route))
        print("      (to train RL agent on this route)")
        
        print("\nüí° The environment is now calibrated with YOUR real data!")
        print("   All price ranges, competitor behavior, and demand patterns")
        print("   are based on actual flight prices from your dataset.")
        
    except Exception as e:
        print(f"\n‚ùå Error during analysis: {e}")
        import traceback
        traceback.print_exc()
        
        print("\nüí° Troubleshooting:")
        print("   - Check your CSV format")
        print("   - Ensure price column has numeric values")
        print("   - Verify airline and route columns exist")


def create_route_visualizations(df, route):
    """Create visualizations for the route"""
    route_df = df[df['route'] == route]
    
    # Create results directory
    os.makedirs('results', exist_ok=True)
    
    # Set style
    sns.set_style('darkgrid')
    
    # Create figure with subplots
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle(f'Flight Analysis: {route}', fontsize=16, fontweight='bold')
    
    # 1. Price Distribution
    axes[0, 0].hist(route_df['price'], bins=30, edgecolor='black', alpha=0.7, color='skyblue')
    axes[0, 0].axvline(route_df['price'].mean(), color='red', linestyle='--', 
                       linewidth=2, label=f'Mean: ‚Çπ{route_df["price"].mean():.0f}')
    axes[0, 0].axvline(route_df['price'].median(), color='green', linestyle='--', 
                       linewidth=2, label=f'Median: ‚Çπ{route_df["price"].median():.0f}')
    axes[0, 0].set_xlabel('Price (‚Çπ)', fontsize=12)
    axes[0, 0].set_ylabel('Frequency', fontsize=12)
    axes[0, 0].set_title('Price Distribution', fontsize=14, fontweight='bold')
    axes[0, 0].legend()
    axes[0, 0].grid(True, alpha=0.3)
    
    # 2. Price by Airline
    airline_prices = route_df.groupby('airline')['price'].agg(['mean', 'std']).sort_values('mean')
    axes[0, 1].barh(airline_prices.index, airline_prices['mean'], 
                    xerr=airline_prices['std'], capsize=5, alpha=0.7, color='coral')
    axes[0, 1].set_xlabel('Average Price (‚Çπ)', fontsize=12)
    axes[0, 1].set_title('Price by Airline', fontsize=14, fontweight='bold')
    axes[0, 1].grid(True, alpha=0.3, axis='x')
    
    # 3. Price vs Duration (if available)
    if 'duration_in_min' in route_df.columns:
        scatter = axes[1, 0].scatter(route_df['duration_in_min'], route_df['price'], 
                                     alpha=0.5, c=route_df['price'], cmap='viridis', s=50)
        axes[1, 0].set_xlabel('Duration (minutes)', fontsize=12)
        axes[1, 0].set_ylabel('Price (‚Çπ)', fontsize=12)
        axes[1, 0].set_title('Price vs Duration', fontsize=14, fontweight='bold')
        plt.colorbar(scatter, ax=axes[1, 0], label='Price (‚Çπ)')
        axes[1, 0].grid(True, alpha=0.3)
        
        # Add trend line
        z = np.polyfit(route_df['duration_in_min'].dropna(), 
                      route_df['price'][route_df['duration_in_min'].notna()], 1)
        p = np.poly1d(z)
        axes[1, 0].plot(sorted(route_df['duration_in_min']), 
                       p(sorted(route_df['duration_in_min'])), 
                       "r--", alpha=0.8, linewidth=2, label='Trend')
        axes[1, 0].legend()
    else:
        axes[1, 0].text(0.5, 0.5, 'Duration data not available', 
                       ha='center', va='center', fontsize=14)
        axes[1, 0].set_title('Price vs Duration', fontsize=14, fontweight='bold')
    
    # 4. Price Statistics Summary
    stats_text = f"""
    Route: {route}
    
    üìä Price Statistics:
    Mean: ‚Çπ{route_df['price'].mean():.2f}
    Median: ‚Çπ{route_df['price'].median():.2f}
    Std Dev: ‚Çπ{route_df['price'].std():.2f}
    Min: ‚Çπ{route_df['price'].min():.2f}
    Max: ‚Çπ{route_df['price'].max():.2f}
    
    ‚úàÔ∏è Flight Information:
    Total Flights: {len(route_df)}
    Airlines: {route_df['airline'].nunique()}
    
    üéØ Recommended Pricing:
    Base Price: ‚Çπ{route_df['price'].mean():.0f}
    Lower Bound: ‚Çπ{route_df['price'].quantile(0.25):.0f}
    Upper Bound: ‚Çπ{route_df['price'].quantile(0.75):.0f}
    """
    
    axes[1, 1].text(0.1, 0.5, stats_text, fontsize=11, verticalalignment='center',
                   family='monospace', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    axes[1, 1].axis('off')
    axes[1, 1].set_title('Summary Statistics', fontsize=14, fontweight='bold')
    
    plt.tight_layout()
    
    # Save
    save_path = f'results/route_analysis_{route.replace("/", "_")}.png'
    plt.savefig(save_path, dpi=300, bbox_inches='tight')
    print(f"   ‚úì Saved visualization: {save_path}")
    
    plt.close()


if __name__ == "__main__":
    main()